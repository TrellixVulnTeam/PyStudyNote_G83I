传递参数
    1.参数的传递是通过自动将对象赋值给本地变量名实现的
    2.在函数内部的参数名不会影响调用者
    3.改变函数的可变参数的值也许会对调用者有影响
    4.不可变参数通过"值"进行传递
    5.可变对象通过"指针"进行传递
        注意:1>若要避免可变参数的修改可以简单创建一个可变对象的拷贝,如:f(x,L[:])
             2>若可变参数是元祖会触发异常

特定的参数匹配模型：
    1.基础知识
        1>位置：从左往右进行匹配
        2>关键字参数：通过参数进行匹配，name=value
        3>默认参数：为没有传入值的参数定义参数值
        4>可变参数：手机任意多基于位置或关键字的参数，用*或**开头
        5>可变参数解包：传递任意多基于位置或关键字的参数
        6>keyword-only参数：参数必须按照名称传递
    2.匹配语法
        1>创建函数
            def func(name)
            def func(value=name)
            def func(*name)     #可变参数，收集不匹配的位置参数放入元祖name中
            def func(**name)    #可变参数，收集不匹配的关键字参数放入字典name中
            def func(*args, name)
            def func(*, name=value)
        2>调用函数
            f(value)
            f(name=value)
            f(*seq)     #f(*[1,2]) 相当于f(1,2),基于位置的可变参数解包
            f(**dict)   #f(**{'a':1,'b':2}) 相当于 f(a=1,b=2),基于关键字的可变参数解包
    3.混合参数细节(结构可缺省，不可多余)
        1>定义函数时，参数排列顺序：一般参数(name) + 默认参数(n=v) + *name + keyword-only参数(name或n=v) +**name
        2>调用函数时，参数排列顺序：位置参数value + 关键字参数(n=v) + *seq形式组合 + **dict形式
        3>参数匹配步骤
            a.通过位置分配非关键字参数
            b.通过匹配变量名分配关键字参数
            c.其它额外的非关键字参数分配到*name元祖中
            d.其它额外的关键字参数分配到**name字典中
            e.用默认值分配给在头部未得到分配的非位置匹配参数
    4.应用函数通用性：当不确定参数列表的时候，可使用混合参数实现通用性，例如：
        def tracer(func,*pargs,**kargs):
            print('calling:', func.__name__)
            return func(*pargs, **kargs)
        def func(a, b, c, d):
            return a + b + c + d
        print(tracer(func, 1, 2, c=3, d=4))